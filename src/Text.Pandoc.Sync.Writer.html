<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DataKinds           #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE GADTs               #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase          #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE PolyKinds           #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE TypeApplications    #-}</span><span>
</span><a name="line-7"></a><span>
</span><a name="line-8"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Sync</span><span class="hs-operator">.</span><span class="hs-identifier">Writer</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-9"></a><span>    </span><a href="Text.Pandoc.Sync.Writer.html#writePandoc"><span class="hs-identifier hs-var">writePandoc</span></a><span>
</span><a name="line-10"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-11"></a><span>
</span><a name="line-12"></a><span class="hs-comment">-- import qualified Text.Pandoc.MediaBag      as P</span><span>
</span><a name="line-13"></a><span class="hs-comment">-- import qualified Text.Pandoc.Readers.LaTeX as P</span><span>
</span><a name="line-14"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span>
</span><a name="line-15"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Exception</span><span>
</span><a name="line-16"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span> </span><span class="hs-keyword">hiding</span><span>          </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;.&gt;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">%~</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a name="line-17"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>
</span><a name="line-18"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span class="hs-operator">.</span><span class="hs-identifier">Class</span><span>
</span><a name="line-19"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span class="hs-operator">.</span><span class="hs-identifier">Trans</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-20"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Default</span><span>
</span><a name="line-21"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-22"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-23"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-24"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Decide</span><span>
</span><a name="line-25"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span class="hs-operator">.</span><span class="hs-identifier">Prelude</span><span class="hs-operator">.</span><span class="hs-identifier">Bool</span><span>
</span><a name="line-26"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">Directory</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">FilePath</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span class="hs-operator">.</span><span class="hs-identifier">Error</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><a href="Text.Pandoc.Sync.Format.html"><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Sync</span><span class="hs-operator">.</span><span class="hs-identifier">Format</span></a><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">ByteString</span><span class="hs-operator">.</span><span class="hs-identifier">Lazy</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">B</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Lazy</span><span class="hs-operator">.</span><span class="hs-identifier">Encoding</span><span>      </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TL</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Lazy</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span>            </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TL</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span>                  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><a href="Text.Pandoc.Lens.App.html"><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span class="hs-operator">.</span><span class="hs-identifier">App</span></a><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Options</span><span>          </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">PDF</span><span>              </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">SelfContained</span><span>    </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Shared</span><span>           </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Templates</span><span>        </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">MediaBag</span><span>         </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">P</span><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">UTF8</span><span>             </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">UTF8</span><span>
</span><a name="line-42"></a><span>
</span><a name="line-43"></a><span class="hs-identifier">writePandoc</span><span>
</span><a name="line-44"></a><span>    </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">SingI</span><span> </span><a href="#local-6989586621679298142"><span class="hs-identifier hs-type">r</span></a><span>
</span><a name="line-45"></a><span>    </span><span class="hs-glyph">=&gt;</span><span> </span><a href="Text.Pandoc.Sync.Format.html#Format"><span class="hs-identifier hs-type">Format</span></a><span> </span><a href="#local-6989586621679298142"><span class="hs-identifier hs-type">r</span></a><span> </span><span class="hs-char">'True
    -&gt; P.Pandoc
    -&gt; P.MediaBag
    -&gt; WriterOptions
    -&gt; FilePath
    -&gt; IO ()
writePandoc ft pd bag wo fp = do
    wo' &lt;- mkWriterOptions ft wo bag
    case formatWriter ft of
      P.IOStringWriter f -&gt;
        UTF8.writeFile fp                =&lt;&lt; f wo' pd
      P.IOByteStringWriter f -&gt;
        B.writeFile (UTF8.encodePath fp) =&lt;&lt; f wo' pd
      P.PureStringWriter f -&gt; case ft of
        FPDF pdft -&gt; do
          let eng = pdfEngine pdft
          -- TODO: handle lack of prog?
          mbPdfProg &lt;- findExecutable eng
          print $ has _Just mbPdfProg
          res &lt;- P.makePDF eng f wo' pd
          putStrLn $ &quot;hey pdf! &quot; ++ fp
          -- TODO: handle bad res?
          case res of
            Right res' -&gt; B.writeFile (UTF8.encodePath fp) res'
            Left  err  -&gt; do
              putStrLn &quot;Failed pdf?&quot;
              TL.putStrLn . TL.decodeUtf8 $ err
              -- B.writeFile (UTF8.encodePath fp) err
        _ -&gt; do
            let res = f wo' pd
            out &lt;- if htmlFormat ft
               then P.makeSelfContained wo' res
               else return res
            UTF8.writeFile fp out

mkWriterOptions
    :: forall r. SingI r
    =&gt; Format r 'True
    -&gt; WriterOptions
    -&gt; P.MediaBag
    -&gt; IO P.WriterOptions
mkWriterOptions ft wo bag = do
    datadir &lt;- runMaybeT $
          MaybeT (return $ wo ^. woDataDir)
      &lt;|&gt; MaybeT (catch @SomeException
                        (Just &lt;$&gt; getAppUserDataDirectory &quot;pandoc&quot;)
                        (\_ -&gt; return Nothing                     )
                 )

    templ &lt;- case wo ^. woTemplatePath of
      _ | not standalone -&gt; return Nothing
      Nothing -&gt;
        either throwIO (return . Just) =&lt;&lt; P.getDefaultTemplate datadir (writerString ft)
      Just tp -&gt; do
        -- strip off extensions
        let tp' = case takeExtension tp of
                    &quot;&quot;   -&gt; tp &lt;.&gt; writerString ft
                    _    -&gt; tp
        Just &lt;$&gt; catch (UTF8.readFile tp')
          (\e -&gt; if isDoesNotExistError e
                    then catch @SomeException
                               (P.readDataFileUTF8 datadir (&quot;templates&quot; &lt;/&gt; tp'))
                               throwIO
                    else throwIO e
          )

    mathVar &lt;- forM (wo ^? woMathMethod . P._LaTeXMathML . _Nothing) $ \_ -&gt; do
       s &lt;- P.readDataFileUTF8 datadir &quot;LaTeXMathML.js&quot;
       return (&quot;mathml-script&quot;, s)
    dzVar   &lt;- runMaybeT @IO @(String, String) $ do
      Refl &lt;- MaybeT . return $ (sing @_ @r %~ SFalse) ^? _Proved
      ()   &lt;- MaybeT . return $ ft ^? _FSlideShow . _SSDZSlides
      liftIO $ do
        dztempl &lt;- P.readDataFileUTF8 datadir (&quot;dzslides&quot; &lt;/&gt; &quot;template.html&quot;)
        let dzline = &quot;&lt;!-- {{{{ dzslides core&quot;
            dzcore = unlines
                   $ dropWhile (not . (dzline `isPrefixOf`))
                   $ lines dztempl
        return (&quot;dzslides-core&quot;, dzcore)
    let variables = concat [ maybeToList mathVar
                           , maybeToList dzVar
                           , wo ^. woVariables
                           ]

    return def { P.writerTemplate        = templ
               , P.writerVariables       = variables
               , P.writerTabStop         = wo ^. woTabStop
               , P.writerTableOfContents = wo ^. woTOC
               , P.writerHTMLMathMethod  = wo ^. woMathMethod
               , P.writerMediaBag        = bag
               }

  where
    standalone = wo ^. woStandalone
              || not (isTextFormat ft)
              || case ft of FPDF _ -&gt; True; _ -&gt; False

--   let writerOptions = def { writerTemplate         = templ,
--                             writerVariables        = variables'',
--                             writerTabStop          = tabStop,
--                             writerTableOfContents  = toc,
--                             writerHTMLMathMethod   = mathMethod,
--                             writerIncremental      = incremental,
--                             writerCiteMethod       = citeMethod,
--                             writerIgnoreNotes      = False,
--                             writerNumberSections   = numberSections,
--                             writerNumberOffset     = numberFrom,
--                             writerSectionDivs      = sectionDivs,
--                             writerReferenceLinks   = referenceLinks,
--                             writerReferenceLocation = referenceLocation,
--                             writerDpi              = dpi,
--                             writerWrapText         = wrap,
--                             writerColumns          = columns,
--                             writerEmailObfuscation = obfuscationMethod,
--                             writerIdentifierPrefix = idPrefix,
--                             writerSourceURL        = sourceURL,
--                             writerUserDataDir      = datadir,
--                             writerHtml5            = html5,
--                             writerHtmlQTags        = htmlQTags,
--                             writerTopLevelDivision = topLevelDivision,
--                             writerListings         = listings,
--                             writerBeamer           = False,
--                             writerSlideLevel       = slideLevel,
--                             writerHighlight        = highlight,
--                             writerHighlightStyle   = highlightStyle,
--                             writerSetextHeaders    = setextHeaders,
--                             writerTeXLigatures     = texLigatures,
--                             writerEpubMetadata     = epubMetadata,
--                             writerEpubStylesheet   = epubStylesheet,
--                             writerEpubFonts        = epubFonts,
--                             writerEpubChapterLevel = epubChapterLevel,
--                             writerTOCDepth         = epubTOCDepth,
--                             writerReferenceODT     = referenceODT,
--                             writerReferenceDocx    = referenceDocx,
--                             writerMediaBag         = media,
--                             writerVerbose          = verbose,
--                             writerLaTeXArgs        = latexEngineArgs
--                           }

isTextFormat :: Format r 'True -&gt; Bool
isTextFormat = \case
    FODT    -&gt; True
    FDocX   -&gt; True
    FEPub _ -&gt; True
    _       -&gt; False

-- TODO: customizable latex engine
pdfEngine
    :: PDFType
    -&gt; String
pdfEngine = \case
    PTLaTeX   -&gt; &quot;pdflatex&quot;
    PTBeamer  -&gt; &quot;pdflatex&quot;
    PTContext -&gt; &quot;context&quot;
    PTHTML5   -&gt; &quot;wkhtmltopdf&quot;

htmlFormat
    :: Format r w
    -&gt; Bool
htmlFormat = \case
    FHTML _ -&gt; True
    FSlideShow ss -&gt; case ss of
      SSBeamer -&gt; False
      _        -&gt; True
    _       -&gt; False

-- convertWithOpts :: Opt -&gt; [FilePath] -&gt; IO ()
-- convertWithOpts opts args = do
--   let Opt    {  optTabStop               = tabStop
--               , optPreserveTabs          = preserveTabs
--               , optStandalone            = standalone
--               , optReader                = readerName
--               , optWriter                = writerName
--               , optParseRaw              = parseRaw
--               , optVariables             = variables
--               , optMetadata              = metadata
--               , optTableOfContents       = toc
--               , optTransforms            = transforms
--               , optTemplate              = templatePath
--               , optOutputFile            = outputFile
--               , optNumberSections        = numberSections
--               , optNumberOffset          = numberFrom
--               , optSectionDivs           = sectionDivs
--               , optIncremental           = incremental
--               , optSelfContained         = selfContained
--               , optSmart                 = smart
--               , optOldDashes             = oldDashes
--               , optHtml5                 = html5
--               , optHtmlQTags             = htmlQTags
--               , optHighlight             = highlight
--               , optHighlightStyle        = highlightStyle
--               , optTopLevelDivision      = topLevelDivision
--               , optHTMLMathMethod        = mathMethod'
--               , optReferenceODT          = referenceODT
--               , optReferenceDocx         = referenceDocx
--               , optEpubStylesheet        = epubStylesheet
--               , optEpubMetadata          = epubMetadata
--               , optEpubFonts             = epubFonts
--               , optEpubChapterLevel      = epubChapterLevel
--               , optTOCDepth              = epubTOCDepth
--               , optDumpArgs              = dumpArgs
--               , optIgnoreArgs            = ignoreArgs
--               , optVerbose               = verbose
--               , optReferenceLinks        = referenceLinks
--               , optReferenceLocation     = referenceLocation
--               , optDpi                   = dpi
--               , optWrapText              = wrap
--               , optColumns               = columns
--               , optFilters               = filters
--               , optEmailObfuscation      = obfuscationMethod
--               , optIdentifierPrefix      = idPrefix
--               , optIndentedCodeClasses   = codeBlockClasses
--               , optDataDir               = mbDataDir
--               , optCiteMethod            = citeMethod
--               , optListings              = listings
--               , optLaTeXEngine           = latexEngine
--               , optLaTeXEngineArgs       = latexEngineArgs
--               , optSlideLevel            = slideLevel
--               , optSetextHeaders         = setextHeaders
--               , optAscii                 = ascii
--               , optTeXLigatures          = texLigatures
--               , optDefaultImageExtension = defaultImageExtension
--               , optExtractMedia          = mbExtractMedia
--               , optTrace                 = trace
--               , optTrackChanges          = trackChanges
--               , optFileScope            = fileScope
--               , optKaTeXStylesheet       = katexStylesheet
--               , optKaTeXJS               = katexJS
--              } = opts

--   when dumpArgs $
--     do UTF8.hPutStrLn stdout outputFile
--        mapM_ (UTF8.hPutStrLn stdout) args
--        exitSuccess

--   let csscdn = &quot;https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.6.0/katex.min.css&quot;
--   let mathMethod =
--         case (katexJS, katexStylesheet) of
--             (Nothing, _) -&gt; mathMethod'
--             (Just js, ss) -&gt; KaTeX js (fromMaybe csscdn ss)


--   -- --bibliography implies -F pandoc-citeproc for backwards compatibility:
--   let needsCiteproc = isJust (M.lookup &quot;bibliography&quot; (optMetadata opts)) &amp;&amp;
--                       optCiteMethod opts `notElem` [Natbib, Biblatex] &amp;&amp;
--                       &quot;pandoc-citeproc&quot; `notElem` map takeBaseName filters
--   let filters' = if needsCiteproc then &quot;pandoc-citeproc&quot; : filters
--                                   else filters

--   let sources = if ignoreArgs then [] else args

--   datadir &lt;- case mbDataDir of
--                   Nothing   -&gt; E.catch
--                                  (Just &lt;$&gt; getAppUserDataDirectory &quot;pandoc&quot;)
--                                  (\e -&gt; let _ = (e :: E.SomeException)
--                                         in  return Nothing)
--                   Just _    -&gt; return mbDataDir

--   -- assign reader and writer based on options and filenames
--   let readerName' = case map toLower readerName of
--                           []       -&gt; defaultReaderName
--                                       (if any isURI sources
--                                           then &quot;html&quot;
--                                           else &quot;markdown&quot;) sources
--                           &quot;html4&quot;  -&gt; &quot;html&quot;
--                           x        -&gt; x

--   let writerName' = case map toLower writerName of
--                           []        -&gt; defaultWriterName outputFile
--                           &quot;epub2&quot;   -&gt; &quot;epub&quot;
--                           &quot;html4&quot;   -&gt; &quot;html&quot;
--                           x         -&gt; x
--   let format = takeWhile (`notElem` ['+','-'])
--                        $ takeFileName writerName'  -- in case path to lua script

--   let pdfOutput = map toLower (takeExtension outputFile) == &quot;.pdf&quot;

--   let laTeXOutput = format `elem` [&quot;latex&quot;, &quot;beamer&quot;]
--   let conTeXtOutput = format == &quot;context&quot;
--   let html5Output = format == &quot;html5&quot;

--   let laTeXInput = &quot;latex&quot; `isPrefixOf` readerName' ||
--                     &quot;beamer&quot; `isPrefixOf` readerName'

--   writer &lt;- if &quot;.lua&quot; `isSuffixOf` format
--                -- note:  use non-lowercased version writerName
--                then return $ IOStringWriter $ writeCustom writerName
--                else case getWriter writerName' of
--                          Left e  -&gt; err 9 $
--                            if format == &quot;pdf&quot;
--                               then e ++
--                                &quot;\nTo create a pdf with pandoc, use &quot; ++
--                                &quot;the latex or beamer writer and specify\n&quot; ++
--                                &quot;an output file with .pdf extension &quot; ++
--                                &quot;(pandoc -t latex -o filename.pdf).&quot;
--                               else e
--                          Right w -&gt; return w

--   reader &lt;- if &quot;t2t&quot; == readerName'
--               then (mkStringReader .
--                     readTxt2Tags) &lt;$&gt;
--                       getT2TMeta sources outputFile
--               else case getReader readerName' of
--                 Right r  -&gt; return r
--                 Left e   -&gt; err 7 e'
--                   where e' = case readerName' of
--                                   &quot;pdf&quot; -&gt; e ++
--                                      &quot;\nPandoc can convert to PDF, but not from PDF.&quot;
--                                   &quot;doc&quot; -&gt; e ++
--                                      &quot;\nPandoc can convert from DOCX, but not from DOC.\nTry using Word to save your DOC file as DOCX, and convert that with pandoc.&quot;
--                                   _ -&gt; e

--   let standalone' = standalone || not (isTextFormat format) || pdfOutput

--   templ &lt;- case templatePath of
--                 _ | not standalone' -&gt; return Nothing
--                 Nothing -&gt; do
--                            deftemp &lt;- getDefaultTemplate datadir format
--                            case deftemp of
--                                  Left e   -&gt; throwIO e
--                                  Right t  -&gt; return (Just t)
--                 Just tp -&gt; do
--                            -- strip off extensions
--                            let tp' = case takeExtension tp of
--                                           &quot;&quot;   -&gt; tp &lt;.&gt; format
--                                           _    -&gt; tp
--                            Just &lt;$&gt; E.catch (UTF8.readFile tp')
--                              (\e -&gt; if isDoesNotExistError e
--                                        then E.catch
--                                              (readDataFileUTF8 datadir
--                                                 (&quot;templates&quot; &lt;/&gt; tp'))
--                                              (\e' -&gt; let _ = (e' :: E.SomeException)
--                                                      in throwIO e')
--                                        else throwIO e)

--   variables' &lt;- case mathMethod of
--                       LaTeXMathML Nothing -&gt; do
--                          s &lt;- readDataFileUTF8 datadir &quot;LaTeXMathML.js&quot;
--                          return $ (&quot;mathml-script&quot;, s) : variables
--                       _ -&gt; return variables

--   variables'' &lt;- if format == &quot;dzslides&quot;
--                     then do
--                         dztempl &lt;- readDataFileUTF8 datadir
--                                      (&quot;dzslides&quot; &lt;/&gt; &quot;template.html&quot;)
--                         let dzline = &quot;&lt;!-- {{{{ dzslides core&quot;
--                         let dzcore = unlines
--                                    $ dropWhile (not . (dzline `isPrefixOf`))
--                                    $ lines dztempl
--                         return $ (&quot;dzslides-core&quot;, dzcore) : variables'
--                     else return variables'

--   let sourceURL = case sources of
--                     []    -&gt; Nothing
--                     (x:_) -&gt; case parseURI x of
--                                 Just u
--                                   | uriScheme u `elem` [&quot;http:&quot;,&quot;https:&quot;] -&gt;
--                                       Just $ show u{ uriQuery = &quot;&quot;,
--                                                      uriFragment = &quot;&quot; }
--                                 _ -&gt; Nothing

--   let readerOpts = def{ readerSmart = if laTeXInput
--                                          then texLigatures
--                                          else smart || (texLigatures &amp;&amp;
--                                                (laTeXOutput || conTeXtOutput))
--                       , readerStandalone = standalone'
--                       , readerParseRaw = parseRaw
--                       , readerColumns = columns
--                       , readerTabStop = tabStop
--                       , readerOldDashes = oldDashes
--                       , readerIndentedCodeClasses = codeBlockClasses
--                       , readerApplyMacros = not laTeXOutput
--                       , readerDefaultImageExtension = defaultImageExtension
--                       , readerTrace = trace
--                       , readerTrackChanges = trackChanges
--                       , readerFileScope   = fileScope
--                       }

-- #ifdef _WINDOWS
--   let istty = True
-- #else
--   istty &lt;- queryTerminal stdOutput
-- #endif
--   when (istty &amp;&amp; not (isTextFormat format) &amp;&amp; outputFile == &quot;-&quot;) $
--     err 5 $ &quot;Cannot write &quot; ++ format ++ &quot; output to stdout.\n&quot; ++
--             &quot;Specify an output file using the -o option.&quot;

--   let readSources [] = mapM readSource [&quot;-&quot;]
--       readSources srcs = mapM readSource srcs
--       readSource &quot;-&quot; = UTF8.getContents
--       readSource src = case parseURI src of
--                             Just u | uriScheme u `elem` [&quot;http:&quot;,&quot;https:&quot;] -&gt;
--                                        readURI src
--                                    | uriScheme u == &quot;file:&quot; -&gt;
--                                        UTF8.readFile (uriPath u)
--                             _       -&gt; UTF8.readFile src
--       readURI src = do
--         res &lt;- openURL src
--         case res of
--              Left e        -&gt; throwIO e
--              Right (bs,_)  -&gt; return $ UTF8.toString bs

--   let readFiles [] = error &quot;Cannot read archive from stdin&quot;
--       readFiles [x] = B.readFile x
--       readFiles (x:xs) = mapM_ (warn . (&quot;Ignoring: &quot; ++)) xs &gt;&gt; B.readFile x

--   let convertTabs = tabFilter (if preserveTabs || readerName' == &quot;t2t&quot;
--                                  then 0
--                                  else tabStop)

--   let handleIncludes' :: String -&gt; IO (Either PandocError String)
--       handleIncludes' = if readerName' `elem`  [&quot;latex&quot;, &quot;latex+lhs&quot;]
--                                then handleIncludes
--                                else return . Right

--   let sourceToDoc :: [FilePath] -&gt; IO (Pandoc, MediaBag)
--       sourceToDoc sources' = fmap handleError $
--         case reader of
--           StringReader r-&gt; do
--             srcs &lt;- convertTabs . intercalate &quot;\n&quot; &lt;$&gt; readSources sources'
--             doc &lt;- handleIncludes' srcs
--             either (return . Left) (\s -&gt; fmap (,mempty) &lt;$&gt; r readerOpts s) doc
--           ByteStringReader r -&gt; readFiles sources' &gt;&gt;= r readerOpts

--   -- We parse first if (1) fileScope is set, (2), it's a binary
--   -- reader, or (3) we're reading JSON. This is easier to do of an AND
--   -- of negatives as opposed to an OR of positives, so we do default
--   -- parsing if it's a StringReader AND (fileScope is set AND it's not
--   -- a JSON reader).
--   (doc, media) &lt;- case reader of
--     (StringReader _) | not fileScope &amp;&amp; readerName' /= &quot;json&quot; -&gt;
--                          sourceToDoc sources
--     _ | null sources -&gt; sourceToDoc sources
--     _  -&gt; do pairs &lt;- mapM (\s -&gt; sourceToDoc [s]) sources
--              return (mconcat $ map fst pairs, mconcat $ map snd pairs)

--   let writerOptions = def { writerTemplate         = templ,
--                             writerVariables        = variables'',
--                             writerTabStop          = tabStop,
--                             writerTableOfContents  = toc,
--                             writerHTMLMathMethod   = mathMethod,
--                             writerIncremental      = incremental,
--                             writerCiteMethod       = citeMethod,
--                             writerIgnoreNotes      = False,
--                             writerNumberSections   = numberSections,
--                             writerNumberOffset     = numberFrom,
--                             writerSectionDivs      = sectionDivs,
--                             writerReferenceLinks   = referenceLinks,
--                             writerReferenceLocation = referenceLocation,
--                             writerDpi              = dpi,
--                             writerWrapText         = wrap,
--                             writerColumns          = columns,
--                             writerEmailObfuscation = obfuscationMethod,
--                             writerIdentifierPrefix = idPrefix,
--                             writerSourceURL        = sourceURL,
--                             writerUserDataDir      = datadir,
--                             writerHtml5            = html5,
--                             writerHtmlQTags        = htmlQTags,
--                             writerTopLevelDivision = topLevelDivision,
--                             writerListings         = listings,
--                             writerBeamer           = False,
--                             writerSlideLevel       = slideLevel,
--                             writerHighlight        = highlight,
--                             writerHighlightStyle   = highlightStyle,
--                             writerSetextHeaders    = setextHeaders,
--                             writerTeXLigatures     = texLigatures,
--                             writerEpubMetadata     = epubMetadata,
--                             writerEpubStylesheet   = epubStylesheet,
--                             writerEpubFonts        = epubFonts,
--                             writerEpubChapterLevel = epubChapterLevel,
--                             writerTOCDepth         = epubTOCDepth,
--                             writerReferenceODT     = referenceODT,
--                             writerReferenceDocx    = referenceDocx,
--                             writerMediaBag         = media,
--                             writerVerbose          = verbose,
--                             writerLaTeXArgs        = latexEngineArgs
--                           }


--   doc' &lt;- (maybe return (extractMedia media) mbExtractMedia &gt;=&gt;
--            adjustMetadata metadata &gt;=&gt;
--            applyTransforms transforms &gt;=&gt;
--            applyFilters datadir filters' [format]) doc

--   let writeFnBinary :: FilePath -&gt; B.ByteString -&gt; IO ()
--       writeFnBinary &quot;-&quot; = B.putStr
--       writeFnBinary f   = B.writeFile (UTF8.encodePath f)

--   let writerFn :: FilePath -&gt; String -&gt; IO ()
--       writerFn &quot;-&quot; = UTF8.putStr
--       writerFn f   = UTF8.writeFile f

--   case writer of
--     IOStringWriter f -&gt; f writerOptions doc' &gt;&gt;= writerFn outputFile
--     IOByteStringWriter f -&gt; f writerOptions doc' &gt;&gt;= writeFnBinary outputFile
--     PureStringWriter f
--       | pdfOutput -&gt; do
--               -- make sure writer is latex or beamer or context or html5
--               unless (laTeXOutput || conTeXtOutput || html5Output) $
--                 err 47 $ &quot;cannot produce pdf output with &quot; ++ format ++
--                          &quot; writer&quot;

--               let pdfprog = case () of
--                               _ | conTeXtOutput -&gt; &quot;context&quot;
--                               _ | html5Output   -&gt; &quot;wkhtmltopdf&quot;
--                               _                 -&gt; latexEngine
--               -- check for pdf creating program
--               mbPdfProg &lt;- findExecutable pdfprog
--               when (isNothing mbPdfProg) $
--                    err 41 $ pdfprog ++ &quot; not found. &quot; ++
--                      pdfprog ++ &quot; is needed for pdf output.&quot;

--               res &lt;- makePDF pdfprog f writerOptions doc'
--               case res of
--                    Right pdf -&gt; writeFnBinary outputFile pdf
--                    Left err' -&gt; do
--                      B.hPutStr stderr err'
--                      B.hPut stderr $ B.pack [10]
--                      err 43 &quot;Error producing PDF&quot;
--       | otherwise -&gt; selfcontain (f writerOptions doc' ++
--                                   ['\n' | not standalone'])
--                       &gt;&gt;= writerFn outputFile . handleEntities
--           where htmlFormat = format `elem`
--                   [&quot;html&quot;,&quot;html5&quot;,&quot;s5&quot;,&quot;slidy&quot;,&quot;slideous&quot;,&quot;dzslides&quot;,&quot;revealjs&quot;]
--                 selfcontain = if selfContained &amp;&amp; htmlFormat
--                                  then makeSelfContained writerOptions
--                                  else return
--                 handleEntities = if htmlFormat &amp;&amp; ascii
--                                     then toEntities
--                                     else id

_Proved :: Prism' (Decision a) a
_Proved = prism Proved (\case Proved x -&gt; Right x
                              d        -&gt; Left d
                       )
</span></pre></body></html>