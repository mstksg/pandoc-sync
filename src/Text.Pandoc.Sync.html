<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE DeriveGeneric     #-}</span><span>
</span><a name="line-2"></a><span class="hs-pragma">{-# LANGUAGE LambdaCase        #-}</span><span>
</span><a name="line-3"></a><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><a name="line-4"></a><span class="hs-pragma">{-# LANGUAGE TemplateHaskell   #-}</span><span>
</span><a name="line-5"></a><span class="hs-pragma">{-# LANGUAGE TupleSections     #-}</span><span>
</span><a name="line-6"></a><span class="hs-pragma">{-# LANGUAGE TypeOperators     #-}</span><span>
</span><a name="line-7"></a><span class="hs-pragma">{-# LANGUAGE ViewPatterns      #-}</span><span>
</span><a name="line-8"></a><span>
</span><a name="line-9"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Sync</span><span> </span><span class="hs-special">(</span><span>
</span><a name="line-10"></a><span>    </span><a href="Text.Pandoc.Sync.html#FileExt"><span class="hs-identifier hs-type">FileExt</span></a><span>
</span><a name="line-11"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#DiscoverMode"><span class="hs-identifier hs-type">DiscoverMode</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-12"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#SyncConfig"><span class="hs-identifier hs-type">SyncConfig</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-13"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#FileDiscover"><span class="hs-identifier hs-type">FileDiscover</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-14"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#Sync"><span class="hs-identifier hs-type">Sync</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a name="line-15"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#loadSync"><span class="hs-identifier hs-var">loadSync</span></a><span>
</span><a name="line-16"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#initSync"><span class="hs-identifier hs-var">initSync</span></a><span>
</span><a name="line-17"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#runSync"><span class="hs-identifier hs-var">runSync</span></a><span>
</span><a name="line-18"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#discoverSync"><span class="hs-identifier hs-var">discoverSync</span></a><span>
</span><a name="line-19"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#withSync"><span class="hs-identifier hs-var">withSync</span></a><span>
</span><a name="line-20"></a><span>  </span><span class="hs-special">,</span><span> </span><a href="Text.Pandoc.Sync.html#withSync_"><span class="hs-identifier hs-var">withSync_</span></a><span>
</span><a name="line-21"></a><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">PS</span><span>
</span><a name="line-22"></a><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-23"></a><span>
</span><a name="line-24"></a><span class="hs-comment">-- import           Control.Applicative</span><span>
</span><a name="line-25"></a><span class="hs-comment">-- import           Debug.Trace</span><span>
</span><a name="line-26"></a><span class="hs-comment">-- import qualified Data.Text           as T</span><span>
</span><a name="line-27"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Exception</span><span>
</span><a name="line-28"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Lens</span><span>
</span><a name="line-29"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span>
</span><a name="line-30"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span>
</span><a name="line-31"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Dependent</span><span class="hs-operator">.</span><span class="hs-identifier">Sum</span><span>
</span><a name="line-32"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Hashable</span><span>
</span><a name="line-33"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span>
</span><a name="line-34"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span>
</span><a name="line-35"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Monoid</span><span>
</span><a name="line-36"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Singletons</span><span>
</span><a name="line-37"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span>           </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-38"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">Directory</span><span>
</span><a name="line-39"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">FilePath</span><span>
</span><a name="line-40"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span class="hs-operator">.</span><span class="hs-identifier">Error</span><span>
</span><a name="line-41"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">Log</span><span class="hs-operator">.</span><span class="hs-identifier">Logger</span><span>
</span><a name="line-42"></a><span class="hs-keyword">import</span><span>           </span><a href="Text.Pandoc.Sync.File.html"><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Pandoc</span><span class="hs-operator">.</span><span class="hs-identifier">Sync</span><span class="hs-operator">.</span><span class="hs-identifier">File</span></a><span>  </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">PS</span><span>
</span><a name="line-43"></a><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Printf</span><span>
</span><a name="line-44"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Binary</span><span>            </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">Bi</span><span>
</span><a name="line-45"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Map</span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">M</span><span>
</span><a name="line-46"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Set</span><span>               </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">S</span><span>
</span><a name="line-47"></a><span>
</span><a name="line-48"></a><span class="hs-keyword">type</span><span> </span><a name="FileExt"><a href="Text.Pandoc.Sync.html#FileExt"><span class="hs-identifier">FileExt</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-type">String</span><span>
</span><a name="line-49"></a><span>
</span><a name="line-50"></a><span class="hs-keyword">data</span><span> </span><a name="DiscoverMode"><a href="Text.Pandoc.Sync.html#DiscoverMode"><span class="hs-identifier">DiscoverMode</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="DMSameDir"><a href="Text.Pandoc.Sync.html#DMSameDir"><span class="hs-identifier">DMSameDir</span></a></a><span>
</span><a name="line-51"></a><span>                  </span><span class="hs-glyph">|</span><span> </span><a name="DMParallelTree"><a href="Text.Pandoc.Sync.html#DMParallelTree"><span class="hs-identifier">DMParallelTree</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">M</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">Map</span><span> </span><span class="hs-identifier hs-type">FilePath</span><span> </span><a href="Text.Pandoc.Sync.html#FileExt"><span class="hs-identifier hs-type">FileExt</span></a><span class="hs-special">)</span><span>
</span><a name="line-52"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-53"></a><span>
</span><a name="line-54"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier hs-type">Bi</span><span class="hs-operator hs-type">.</span><span class="hs-identifier hs-type">Binary</span><span> </span><a href="Text.Pandoc.Sync.html#DiscoverMode"><span class="hs-identifier hs-type">DiscoverMode</span></a><span>
</span><a name="line-55"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier hs-type">Hashable</span><span> </span><a href="Text.Pandoc.Sync.html#DiscoverMode"><span class="hs-identifier hs-type">DiscoverMode</span></a><span> </span><span class="hs-keyword">where</span><span>
</span><a name="line-56"></a><span>    </span><a name="local-8214565720323808476"><span class="hs-identifier">hashWithSalt</span></a><span> </span><a name="local-6989586621679554677"><a href="#local-6989586621679554677"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="hs-keyword">case</span><span>
</span><a name="line-57"></a><span>      </span><a href="Text.Pandoc.Sync.html#DMSameDir"><span class="hs-identifier hs-var">DMSameDir</span></a><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679554677"><span class="hs-identifier hs-var">s</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">hashWithSalt</span><span class="hs-special">`</span><span> </span><span class="hs-special">(</span><span class="hs-number">0</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span class="hs-special">)</span><span>
</span><a name="line-58"></a><span>      </span><a href="Text.Pandoc.Sync.html#DMParallelTree"><span class="hs-identifier hs-var">DMParallelTree</span></a><span> </span><a name="local-6989586621679554678"><a href="#local-6989586621679554678"><span class="hs-identifier">mp</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="#local-6989586621679554677"><span class="hs-identifier hs-var">s</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">hashWithSalt</span><span class="hs-special">`</span><span> </span><span class="hs-special">(</span><span class="hs-number">1</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">Int</span><span class="hs-special">)</span><span>
</span><a name="line-59"></a><span>                             </span><span class="hs-special">`</span><span class="hs-identifier hs-var">hashWithSalt</span><span class="hs-special">`</span><span> </span><span class="hs-identifier hs-var">M</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">toList</span><span> </span><a href="#local-6989586621679554678"><span class="hs-identifier hs-var">mp</span></a><span>
</span><a name="line-60"></a><span>
</span><a name="line-61"></a><span class="hs-comment">-- instance FromJSON DiscoverMode where</span><span>
</span><a name="line-62"></a><span class="hs-comment">--     parseJSON = withObject &quot;DiscoverMode&quot; $ \v -&gt; do</span><span>
</span><a name="line-63"></a><span class="hs-comment">--       mode &lt;- v .: &quot;mode&quot;</span><span>
</span><a name="line-64"></a><span class="hs-comment">--       case mode :: T.Text of</span><span>
</span><a name="line-65"></a><span class="hs-comment">--         &quot;same-dir&quot; -&gt; pure DMSameDir</span><span>
</span><a name="line-66"></a><span class="hs-comment">--         &quot;parallel&quot; -&gt; DMParallelTree &lt;$&gt; v .: &quot;format-tree&quot;</span><span>
</span><a name="line-67"></a><span>
</span><a name="line-68"></a><span>
</span><a name="line-69"></a><span class="hs-keyword">data</span><span> </span><a name="FileDiscover"><a href="Text.Pandoc.Sync.html#FileDiscover"><span class="hs-identifier">FileDiscover</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a name="FD"><a href="Text.Pandoc.Sync.html#FD"><span class="hs-identifier">FD</span></a></a><span> </span><span class="hs-special">{</span><span> </span><a name="_fdBaseDir"><a href="Text.Pandoc.Sync.html#_fdBaseDir"><span class="hs-identifier">_fdBaseDir</span></a></a><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">FilePath</span><span>
</span><a name="line-70"></a><span>                       </span><span class="hs-special">,</span><span> </span><a name="_fdFileName"><a href="Text.Pandoc.Sync.html#_fdFileName"><span class="hs-identifier">_fdFileName</span></a></a><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">String</span><span>
</span><a name="line-71"></a><span>                       </span><span class="hs-special">}</span><span>
</span><a name="line-72"></a><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Show</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Eq</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Ord</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a name="line-73"></a><span>
</span><a name="line-74"></a><span class="hs-identifier hs-var">makeLenses</span><span> </span><span class="hs-char">''FileDiscover

instance Bi.Binary FileDiscover

data SyncConfig = SC { _scDiscoverMode :: DiscoverMode
                     , _scFormats      :: M.Map FileExt (Writer FormatOptions)
                     , _scRoot         :: FilePath
                     , _scCache        :: FilePath
                     }
  deriving (Show, Generic)

makeLenses ''SyncConfig

instance Bi.Binary SyncConfig
instance Hashable SyncConfig where
    hashWithSalt s sc = s `hashWithSalt` (sc ^. scDiscoverMode)
                          `hashWithSalt` (sc ^. scRoot)
                          `hashWithSalt` (sc ^. scCache)
                          `hashWithSalt` M.toList (sc ^. scFormats)


instance FromJSON SyncConfig where
    parseJSON = withObject &quot;SyncConfig&quot; $ \v -&gt; do
      pmode &lt;- v .:? &quot;parallel-mode&quot;
      ftree &lt;- v .:? &quot;format-tree&quot;
      dm &lt;- case pmode of
        Just True -&gt; case ftree of
          Just t  -&gt; return $ DMParallelTree t
          Nothing -&gt; fail &quot;Parallel mode indicated, but format-tree required.&quot;
        Just False -&gt; return DMSameDir
        Nothing -&gt; case ftree of
          Just t  -&gt; return $ DMParallelTree t
          Nothing -&gt; return DMSameDir
      fts   &lt;- v .: &quot;formats&quot;
      rt    &lt;- v .:? &quot;root&quot;
      cache &lt;- v .:? &quot;cache&quot;
      return $ SC dm
                  fts
                  (fromMaybe &quot;&quot; rt)
                  (fromMaybe &quot;.pandoc-sync-cache&quot; cache)

data Sync = Sync { _syncFiles    :: M.Map FileDiscover SyncFile
                 , _syncConfHash :: Int
                 }
    deriving (Show, Generic)

makeLenses ''Sync

instance Bi.Binary Sync

initSync :: SyncConfig -&gt; IO Sync
initSync sc = do
    createDirectoryIfMissing True (sc ^. scRoot)
    -- TODO: log &quot;new files&quot;
    res &lt;- case sc ^. scDiscoverMode of
      DMSameDir          -&gt;
        fillSameDir . M.mapWithKey mkSF
          &lt;$&gt; discoverAll (sc ^. scFormats) (sc ^. scRoot)
      DMParallelTree rts -&gt;
        M.mapWithKey (fillParallel rts) . M.unionsWith mergeSF
          &lt;$&gt; traverse (uncurry mkParallel) (M.toList rts)
    forM_ (M.toList res) . uncurry $ \fd sf -&gt;
      infoM &quot;pandoc-sync&quot; $ printf &quot;Consolidated file %s, consisting of paths %s&quot;
        (fd ^. fdBaseDir &lt;/&gt; fd ^. fdFileName)
        (show (sf ^.. sfSourcesSinks . to M.keys . traverse))
    return $ Sync res (hash sc)
  where
    fillSameDir
        :: M.Map FileDiscover SyncFile
        -&gt; M.Map FileDiscover SyncFile
    fillSameDir sfs = M.unionWith mergeSF sfs fills
      where
        fills :: M.Map FileDiscover SyncFile
        fills = M.mapWithKey go sfs
        go :: FileDiscover -&gt; SyncFile -&gt; SyncFile
        go fd = over sfSourcesSinks (`M.union` filled)
          where
            filled :: M.Map FilePath (DSum Sing SyncFileData)
            filled = M.fromList . map (uncurry go2) . M.toList $ sc ^. scFormats
            go2 :: FileExt
                -&gt; Writer FormatOptions
                -&gt; (FilePath, DSum Sing SyncFileData)
            go2 ex (Writer fo) = (fullPath, sfd)
              where
                sfd = sing :=&gt; SyncFileData (fo ^. foFormat)
                                            (fo ^. foReaderOpts)
                                            (fo ^. foWriterOpts . _Has)
                                            Nothing
                fullPath = fd ^. fdBaseDir &lt;/&gt; fd ^. fdFileName -&lt;.&gt; ex
    mkParallel :: FilePath -&gt; FileExt -&gt; IO (M.Map FileDiscover SyncFile)
    mkParallel rt ex = case sc ^? scFormats . ix ex of
      -- TODO: handle bad format?
      Nothing -&gt; return M.empty
      Just wf -&gt;
        let fullRt = sc ^. scRoot &lt;/&gt; rt
        in  do res &lt;- over (traverse . sfSourcesSinks . mapKeys) (fullRt &lt;/&gt;)
                    . M.mapWithKey mkSF
                    . over (mapKeys . fdBaseDir) (fromJust' (stripPrefix fullRt))
                    &lt;$&gt; discoverAll (M.singleton ex wf) fullRt
               return res
    fillParallel :: M.Map FilePath FileExt -&gt; FileDiscover -&gt; SyncFile -&gt; SyncFile
    fillParallel rts fd = over sfSourcesSinks (`M.union` filled)
      where
        filled = M.fromList
               . mapMaybe (uncurry go)
               . M.toList
               $ rts
        go :: FilePath -&gt; FileExt -&gt; Maybe (FilePath, DSum Sing SyncFileData)
        go rt ex = sc ^? scFormats
                       . ix ex
                       . to (\case Writer fo -&gt;
                                    let sfd = sing :=&gt; SyncFileData (fo ^. foFormat)
                                                  (fo ^. foReaderOpts)
                                                  (fo ^. foWriterOpts . _Has)
                                                  Nothing
                                    in  (fullPath, sfd)
                            )
          where
            fullPath = sc ^. scRoot &lt;/&gt; rt &lt;/&gt; fd ^. fdBaseDir &lt;/&gt; fd ^. fdFileName -&lt;.&gt; ex
    mkSF :: FileDiscover -&gt; S.Set FileExt -&gt; SyncFile
    mkSF fd exs = emptySyncFile &amp;
        sfSourcesSinks .~ M.mapKeys mkFileName extMap
      where
        extMap = M.intersectionWith (const go)
                                    (M.fromSet (const ()) exs)
                                    (sc ^. scFormats)
        mkFileName :: FileExt -&gt; FilePath
        mkFileName fe = (fd ^. fdBaseDir) &lt;/&gt; (fd ^. fdFileName) -&lt;.&gt; fe
        go :: Writer FormatOptions -&gt; DSum Sing SyncFileData
        go = \case
          Writer fo -&gt; sing :=&gt;
            SyncFileData (fo ^. foFormat)
                         (fo ^. foReaderOpts)
                         (fo ^. foWriterOpts . _Has)
                         Nothing
    mergeSF :: SyncFile -&gt; SyncFile -&gt; SyncFile
    mergeSF s1 s2 = s1 &amp; sfSourcesSinks %~ (`M.union` (s2 ^. sfSourcesSinks))


fromJust' :: Show a =&gt; (a -&gt; Maybe b) -&gt; a -&gt; b
fromJust' f x = case f x of
                  Nothing -&gt; error $ &quot;fromJust called from applying &quot; ++ show x
                  Just y  -&gt; y

addSync :: Sync -&gt; Sync -&gt; Sync
addSync s0 s1 = s0 &amp; syncFiles %~ M.unionWith go (s1 ^. syncFiles)
  where
    go :: SyncFile -&gt; SyncFile -&gt; SyncFile
    go sf1 sf0 = sf0 &amp; sfSourcesSinks %~ (`M.union` (sf1 ^. sfSourcesSinks))

discoverSync :: SyncConfig -&gt; Sync -&gt; IO Sync
discoverSync sc s0 = addSync s0 &lt;$&gt; initSync sc

runSync :: Sync -&gt; IO Sync
runSync = itraverseOf (syncFiles . itraversed) $ \fd sf -&gt; do
    debugM &quot;pandoc-sync&quot; $ printf &quot;Syncing file %s&quot;
      (fd ^. fdBaseDir &lt;/&gt; fd ^. fdFileName)
    runSyncFile sf

    -- debugM
    -- runSyncFile

loadSync :: SyncConfig -&gt; IO Sync
loadSync sc = do
    es &lt;- fmap join
        . tryJust (guard . isDoesNotExistError)
        . set (mapped . _Left) ()
        $ Bi.decodeFileOrFail (sc ^. scCache)
    case es of
      Right s | s ^. syncConfHash == hash sc -&gt;
        discoverSync sc s
              | otherwise                    -&gt; do
        warningM &quot;pandoc-sync&quot; &quot;Configuration changed&quot;
        removeFile (sc ^. scCache)
        initSync sc
      Left ()                                -&gt;
        initSync sc

withSync :: SyncConfig -&gt; (Sync -&gt; IO (r, Sync)) -&gt; IO r
withSync sc f = do
    s0 &lt;- loadSync sc
    (y, s1) &lt;- f s0
    Bi.encodeFile (sc ^. scCache) s1
    return y

withSync_ :: SyncConfig -&gt; (Sync -&gt; IO Sync) -&gt; IO ()
withSync_ sc f = withSync sc (fmap ((),) . f)

discoverAll
    :: M.Map FileExt (Writer FormatOptions)
    -&gt; FilePath
    -&gt; IO (M.Map FileDiscover (S.Set FileExt))
discoverAll wfs rt = do
    isFile &lt;- doesFileExist rt
    when isFile $ error &quot;There's a file there, what gives?&quot;
    createDirectoryIfMissing True rt
    debugM &quot;pandoc-sync&quot; $ printf &quot;Discovering files in %s with extensions in %s&quot;
        rt (show (M.keys wfs))
    res &lt;- go rt
    forM_ (M.toList res) . uncurry $ \fd exs -&gt;
      debugM &quot;pandoc-sync&quot; $ printf &quot;Found file %s with extensions %s&quot;
        (fd ^. fdBaseDir &lt;/&gt; fd ^. fdFileName)
        (show (S.toList exs))
    return res
  where
    go :: FilePath -&gt; IO (M.Map FileDiscover (S.Set FileExt))
    go fp0 = do
        debugM &quot;pandoc-sync&quot; $ printf &quot;Searching directory %s&quot; fp0
        fmap (M.unionsWith (&lt;&gt;)) . mapM process =&lt;&lt; listDirectory fp0
      where
        process :: FilePath -&gt; IO (M.Map FileDiscover (S.Set FileExt))
        process fp1 = do
          let fullPath = fp0 &lt;/&gt; fp1
          debugM &quot;pandoc-sync&quot; $ printf &quot;Processing file %s&quot; fullPath
          isFile &lt;- doesFileExist fullPath
          let (fn, drop 1 -&gt; ex) = splitExtension fp1
          if isFile
            then return $ if ex `M.member` wfs
                   then M.singleton (FD fp0 fn) (S.singleton ex)
                   else M.empty
            else go fullPath

mapKeys :: (Ord k1, Ord k2) =&gt; Traversal (M.Map k1 v) (M.Map k2 v) k1 k2
mapKeys f = fmap M.fromList . (traverse . _1) f . M.toList
</span></pre></body></html>